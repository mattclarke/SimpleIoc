record(ai, "$(P)VALUE1")
{
	field(VAL, 2)
}

alias("$(P)VALUE1", "$(P)VALUE1:SP")
alias("$(P)VALUE1", "$(P)VALUE1:RBV")

record(bi, "$(P)ENABLED")
{
	field(VAL, 0)
	field(ZNAM, "OFF")
	field(ONAM, "ON")
}

alias("$(P)ENABLED", "$(P)ENABLED:SP")

record(mbbi, "$(P)MBBI")
{
	field(VAL, 0)
	field(ZRST, "ZERO")
	field(ZRVL, 0)
	field(ONST, "ONE")
	field(ONVL, 1)
	field(TWST, "TWO")
	field(TWVL, 2)
	field(THST, "THREE")
	field(THVL, 3)

}

record(ai, "$(P)VALUE2")
{
	field(VAL, 10)
	field(LOW, 2)
	field(LSV, "MINOR")
	field(LOLO, 0)
	field(LLSV, "MAJOR")
	field(HIGH, 18)
	field(HSV, "MINOR")
	field(HIHI, 20)
	field(HHSV, "MAJOR")
}

alias("$(P)VALUE2", "$(P)VALUE2:SP")
alias("$(P)VALUE2", "$(P)VALUE2:RBV")

record(stringin, "$(P)STRVALUE1")
{
	field(VAL, "Hello")
}

record(aai, "$(P)AAI")
{
    field(NELM, 5)
    field(FTVL, 7)
}

record(waveform, "$(P)WAVE")
{
    field(NELM, 5)
    field(FTVL, 7)
}

record(waveform, "$(P)CHARWAVE")
{
    field(NELM, 5)
    field(FTVL, 1)
}

record(stringin, "$(P)UNITS")
{
	field(SCAN, "1 second")
	field(VAL, "K")
}

# Forward units from one PV to another's EGU
# PP will cause the target record to process.
# Use NPP if you don't want that (e.g. on a setpoint)
# CP causes the record to process whenever the PV
# being watched updates.
# CPP could be used too ().
record(stringout, "$(P)UNITS_SET")
{
  	field(DESC, "Push units from one pv to another")
  	field(DOL, "$(P)UNITS CP")
	field(OMSL, "closed_loop")
  	field(OUT,  "$(P)VALUE1.EGU PP")
}

# Debugging: to see when a record is processed
# set TPRO to 1
record(ai, "$(P)VALUE3")
{
	field(VAL, 2)
	field(TPRO, 1)
}

# Something with alarms
record(ai, "$(P)ALARM1")
{
	field(VAL, 10)
	field(LOW, 7)
	field(HIGH, 13)
	field(LOLO, 5)
	field(HIHI, 15)
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(HSV, "MINOR")
	field(HHSV, "MAJOR")
}

# Something else with alarms
record(ai, "$(P)ALARM2")
{
	field(VAL, 10)
	field(LOW, 7)
	field(HIGH, 13)
	field(LOLO, 5)
	field(HIHI, 15)
	field(LSV, "MINOR")
	field(LLSV, "MAJOR")
	field(HSV, "MINOR")
	field(HHSV, "MAJOR")
}

# Calculate but taking the underlying alarms too.
# MSS means take the severity and status of the underlying
# alarm(s).
# Other options are:
#	 MS - the alarm is set to link_alarm rather than the underlying status
#  MSI - only invalid alarm is propagated
#  NMS - don't propagate
record(calc, "$(P)CALC1")
{
	field(CALC, "A+B")
	field(INPA, "$(P)ALARM1 CP MSS")
	# Ignore the alarm from input B
	field(INPB, "$(P)ALARM2 CP NMS")
}

# Calcout is like calc but it writes the result to another record.
# Can also forward alarms as above
# This gives the value of B but with the alarms from A.
record(calcout, "$(P)CALCOUT1")
{
	field(CALC, "B")
	# Get the alarm from A
	field(INPA, "$(P)ALARM1 CP MSS")
	# Ignore the alarm from input B
	field(INPB, "$(P)ALARM2 CP NMS")
	# Must PP the output otherwise it does not get updated
	field(OUT, "$(P)RESULT MSS PP")
}

record(ai, "$(P)RESULT")
{
}

record(calcout, "$(P)CALCOUT_COND")
{
	# Use calc to determine whether to write out value
	# in conjunction with OOPT
	field(CALC, "A>=B?1:0")
	field(OOPT, "When Non-zero")

	# Second calculated value
	field(OCAL, "A+B")
	# Which result to send to OUT - can be changed at runtime
	field(DOPT, "Use OCAL")

	# Inputs
	field(INPA, "$(P)ALARM1 CP")
	field(INPB, "$(P)ALARM2 CP")

	# Outputs
	field(OUT, "$(P)RESULT PP")
}

record(ai, "$(P)COND_RESULT")
{
}

# Requires transform record to be installed
#record (transform, "$(P)PROPAGATE_ALARM")
#{
#	field(DESC, "Propagates the alarm from one PV to another")
#	# Always calculate
# field(COPT, "Always")
#	# Input links
#	field(INPE, "$(P)ALARM2.VAL NPP NMS")
#	field(INPF, "$(P)ALARM1 NPP MS")
#	# Expression - take the value from E and send it to B
#	field(CLCB, "E")
#	# Output the value with the alarms from F
#	field(OUTB, "$(P)ALARM2.VAL PP MS")
#	field(PREC, "3")
#	#field(SDIS, "$(P)$(SLIT)$(S1)_SPALT.PACT")
#}
